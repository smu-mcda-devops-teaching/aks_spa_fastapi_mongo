trigger:
  branches:
    include:
      - main
  paths:
    include:
      - infra/*
      - charts/*
      - azure-pipelines/azure-pipelines-infra.yml

variables:
  # Use a specific version (recommended) or 'latest' to pick newest available in installer task.
  terraformVersion: 'latest' 
  workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
  serviceConnection: 'Azure ARM' # Replace with your Azure service connection name
  imageTag: '$(Build.BuildId)'   # CI build artifact tag - avoid "latest"
  acrName: ''                    # Set to your ACR name to push packaged charts (optional)
  terraformStateRG: 'terraform-state-rg'        # adjust if different
  terraformStateStorageAccount: 'tfstatemcda2025' # adjust if different
  terraformStateContainer: 'tfstate'            # adjust if different

stages:
- stage: ValidateTerraform
  displayName: 'Validate Terraform Configuration (per environment)'
  jobs:
  - job: TerraformValidate
    displayName: 'Terraform Init / Validate / Plan (matrix per infra env)'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      matrix:
        dev:
          envName: 'dev'
          tfvarsFile: 'dev/dev.tfvars'
          backendConfig: 'dev/backend.conf'
        stage:
          envName: 'stage'
          tfvarsFile: 'stage/stage.tfvars'
          backendConfig: 'stage/backend.conf'
        prod:
          envName: 'prod'
          tfvarsFile: 'prod/prod.tfvars'
          backendConfig: 'prod/backend.conf'

    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'

    # Optional: cache provider plugin cache under user's terraform plugin cache if you use plugin caching dir
    - task: Cache@2
      displayName: 'Cache Terraform plugin cache (~/.terraform.d/plugin-cache)'
      inputs:
        key: 'terraform-plugins | $(Agent.OS) | $(envName) | $(Build.SourceVersion)'
        path: '$(HOME)/.terraform.d/plugin-cache'
        restoreKeys: |
          terraform-plugins | $(Agent.OS) | $(envName)
      condition: succeededOrFailed()

    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az account show
      displayName: 'Azure Login'

    - task: AzureCLI@2
      name: tfInit
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
        inlineScript: |
          set -e
          echo "Initializing Terraform with backend config: $(backendConfig)"
          terraform init -input=false -backend-config="$(backendConfig)"
      displayName: 'Terraform Init (env: $(envName))'

    - task: AzureCLI@2
      name: tfValidate
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
        inlineScript: |
          set -e
          terraform validate
      displayName: 'Terraform Validate (env: $(envName))'

    - task: TerraformTaskV4@4
      name: tfPlan
      inputs:
        provider: 'azurerm'
        command: 'plan'
        environmentServiceNameAzureRM: '$(serviceConnection)'
        commandOptions: '-var-file="$(tfvarsFile)" -out="$(Build.ArtifactStagingDirectory)/$(envName)/tfplan"'
        workingDirectory: '$(System.DefaultWorkingDirectory)/infra'

    # - task: AzureCLI@2
    #   name: tfPlan
    #   inputs:
    #     azureSubscription: '$(serviceConnection)'
    #     scriptType: 'bash'
    #     scriptLocation: 'inlineScript'
    #     workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
    #     inlineScript: |
    #       set -e
    #       # Create plan directory if it doesn't exist
    #       mkdir -p $(Build.ArtifactStagingDirectory)/$(envName)
          
    #       echo "Planning Terraform with vars file: $(tfvarsFile)"
    #       terraform plan -input=false \
    #         -var-file="$(tfvarsFile)" \
    #         -out="$(Build.ArtifactStagingDirectory)/$(envName)/tfplan"
    #   displayName: 'Terraform Plan (env: $(envName))'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/$(envName)'
        artifactName: 'tfplan-$(envName)'
        publishLocation: 'pipeline'
      displayName: 'Publish Terraform Plan (env: $(envName))'

- stage: ValidateHelmCharts
  displayName: 'Validate Helm Charts (lint + render templates per env)'
  dependsOn: ValidateTerraform
  condition: succeeded()
  jobs:
  - job: HelmValidate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    # Cache Helm chart repository/cache to speed repeated operations (optional)
    - task: Cache@2
      displayName: 'Cache Helm home/cache'
      inputs:
        key: 'helm | $(Agent.OS) | charts | $(Build.SourceVersion)'
        path: '$(HOME)/.cache/helm'
        restoreKeys: |
          helm | $(Agent.OS) | charts
      condition: succeededOrFailed()

    - script: |
        set -e
        charts=(charts/*)
        envs=("dev" "staging" "prod")
        # Lint all charts
        for c in "${charts[@]}"; do
          if [ -d "$c" ]; then
            helm lint "$c" || true
          fi
        done

        # Render templates for each env to catch value/template errors and inject image tag
        for env in "${envs[@]}"; do
          for c in "${charts[@]}"; do
            if [ -d "$c" ]; then
              name=$(basename "$c")
              vals=""
              vf="$c/values.$env.yaml"
              if [ -f "$vf" ]; then
                vals="-f $vf"
              fi
              echo "Rendering $name for env=$env"
              helm template "$name" "$c" $vals --set image.tag=$(imageTag)
            fi
          done
        done
      displayName: 'Helm lint & template (per environment)'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: PackageCharts
  displayName: 'Package Helm Charts (artifact)'
  dependsOn: ValidateHelmCharts
  condition: succeeded()
  jobs:
  - job: PackageCharts
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    - script: |
        set -e
        mkdir -p "$(Build.ArtifactStagingDirectory)/charts"
        for c in charts/*; do
          if [ -d "$c" ]; then
            name=$(basename "$c")
            # package using imageTag as version to tie chart -> image
            helm package "$c" -d "$(Build.ArtifactStagingDirectory)/charts" --version "$(imageTag)" --app-version "$(imageTag)"
          fi
        done
      displayName: 'Package Helm Charts (version=$(imageTag))'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/charts'
        artifactName: 'helm-charts'
        publishLocation: 'pipeline'
      displayName: 'Publish Helm Packages as Artifact'
