trigger:
  branches:
    include:
      - main
  paths:
    include:
      - infra/*
      - charts/*
      - azure-pipelines/azure-pipelines-infra.yml

variables:
  # Use a specific version (recommended) or 'latest' to pick newest available in installer task.
  terraformVersion: 'latest' 
  workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
  serviceConnection: 'Azure ARM' # Replace with your Azure service connection name
  imageTag: '$(Build.BuildId)'   # CI build artifact tag - avoid "latest"
  acrName: ''                    # Set to your ACR name to push packaged charts (optional)
  terraformStateRG: 'terraform-state-rg'        # adjust if different
  terraformStateStorageAccount: 'tfstatemcda2025' # adjust if different
  terraformStateContainer: 'tfstate'            # adjust if different

stages:
- stage: ValidateTerraform
  displayName: 'Validate Terraform Configuration (per environment)'
  jobs:
  - job: TerraformValidate
    displayName: 'Terraform Init / Validate / Plan (matrix per infra env)'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      matrix:
        dev:
          envName: 'dev'
          infraPath: '$(System.DefaultWorkingDirectory)/infra/dev'
        staging:
          envName: 'staging'
          infraPath: '$(System.DefaultWorkingDirectory)/infra/staging'
        prod:
          envName: 'prod'
          infraPath: '$(System.DefaultWorkingDirectory)/infra/prod'
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'

    # Optional: cache provider plugin cache under user's terraform plugin cache if you use plugin caching dir
    - task: Cache@2
      displayName: 'Cache Terraform plugin cache (~/.terraform.d/plugin-cache)'
      inputs:
        key: 'terraform-plugins | $(Agent.OS) | $(envName) | $(Build.SourceVersion)'
        path: '$(HOME)/.terraform.d/plugin-cache'
        restoreKeys: |
          terraform-plugins | $(Agent.OS) | $(envName)
      condition: succeededOrFailed()

    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az account show
      displayName: 'Azure Login'

    - task: AzureCLI@2
      name: tfInit
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          set -e
          cd $(System.DefaultWorkingDirectory)/infra
          terraform init -backend-config=$(infraPath)/backend.conf
      displayName: 'Terraform Init (env: $(envName))'
    
    # - task: AzureCLI@2
    #   name: tfInit
    #   inputs:
    #     azureSubscription: '$(serviceConnection)'
    #     scriptType: 'bash'
    #     scriptLocation: 'inlineScript'
    #     inlineScript: |
    #       set -e
    #       cd "$(infraPath)"
    #       # prefer backend.conf in env folder
    #       if [ -f "backend.conf" ]; then
    #         echo "Found backend.conf in $(infraPath) — running terraform init with backend-config=backend.conf"
    #         terraform init -input=false -backend-config=backend.conf
    #       else
    #         # fallback: try other common names for compatibility
    #         if [ -f "backend.tfvars" ]; then
    #           echo "Found backend.tfvars — running terraform init with backend-config=backend.tfvars"
    #           terraform init -input=false -backend-config=backend.tfvars
    #         else
    #           echo "No backend config file found in $(infraPath). Running terraform init without extra backend-config"
    #           terraform init -input=false
    #         fi
    #       fi
    #   displayName: 'Terraform Init (env: $(envName)) - use backend.conf if present'

    - task: TerraformTaskV4@4
      name: tfValidate
      inputs:
        provider: 'azurerm'
        command: 'validate'
        workingDirectory: '$(infraPath)'
      displayName: 'Terraform Validate (env: $(envName))'

    # Run 'plan' and write plan file into the infraPath to publish as artifact for per-env apply later.
    - task: AzureCLI@2
      name: tfPlan
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          set -e
          cd $(System.DefaultWorkingDirectory)/infra
          terraform plan -var-file=$(infraPath)/$(envName).tfvars -out=$(infraPath)/tfplan
      displayName: 'Terraform Plan (env: $(envName))'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(infraPath)/tfplan'
        artifactName: 'tfplan-$(envName)'
        publishLocation: 'pipeline'
      displayName: 'Publish Terraform Plan (env: $(envName))'

- stage: ValidateHelmCharts
  displayName: 'Validate Helm Charts (lint + render templates per env)'
  dependsOn: ValidateTerraform
  condition: succeeded()
  jobs:
  - job: HelmValidate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    # Cache Helm chart repository/cache to speed repeated operations (optional)
    - task: Cache@2
      displayName: 'Cache Helm home/cache'
      inputs:
        key: 'helm | $(Agent.OS) | charts | $(Build.SourceVersion)'
        path: '$(HOME)/.cache/helm'
        restoreKeys: |
          helm | $(Agent.OS) | charts
      condition: succeededOrFailed()

    - script: |
        set -e
        charts=(charts/*)
        envs=("dev" "staging" "prod")
        # Lint all charts
        for c in "${charts[@]}"; do
          if [ -d "$c" ]; then
            helm lint "$c" || true
          fi
        done

        # Render templates for each env to catch value/template errors and inject image tag
        for env in "${envs[@]}"; do
          for c in "${charts[@]}"; do
            if [ -d "$c" ]; then
              name=$(basename "$c")
              vals=""
              vf="$c/values.$env.yaml"
              if [ -f "$vf" ]; then
                vals="-f $vf"
              fi
              echo "Rendering $name for env=$env"
              helm template "$name" "$c" $vals --set image.tag=$(imageTag)
            fi
          done
        done
      displayName: 'Helm lint & template (per environment)'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: PackageCharts
  displayName: 'Package Helm Charts (artifact)'
  dependsOn: ValidateHelmCharts
  condition: succeeded()
  jobs:
  - job: PackageCharts
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    - script: |
        set -e
        mkdir -p "$(Build.ArtifactStagingDirectory)/charts"
        for c in charts/*; do
          if [ -d "$c" ]; then
            name=$(basename "$c")
            # package using imageTag as version to tie chart -> image
            helm package "$c" -d "$(Build.ArtifactStagingDirectory)/charts" --version "$(imageTag)" --app-version "$(imageTag)"
          fi
        done
      displayName: 'Package Helm Charts (version=$(imageTag))'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/charts'
        artifactName: 'helm-charts'
        publishLocation: 'pipeline'
      displayName: 'Publish Helm Packages as Artifact'
