trigger:
  branches:
    include:
      - main
  paths:
    include:
      - infra/*
      - charts/*
      - azure-pipelines/azure-pipelines-infra.yml

variables:
  # Use a specific version (recommended) or 'latest' to pick newest available in installer task.
  terraformVersion: 'latest' 
  workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
  serviceConnection: 'Azure ARM' # Replace with your Azure service connection name
  imageTag: '$(Build.BuildId)'   # CI build artifact tag - avoid "latest"
  acrName: ''                    # Set to your ACR name to push packaged charts (optional)
  terraformStateRG: 'terraform-state-rg'        # adjust if different
  terraformStateStorageAccount: 'tfstatemcda2025' # adjust if different
  terraformStateContainer: 'tfstate'            # adjust if different

stages:
- stage: ValidateTerraform
  displayName: 'Validate Terraform Configuration (per environment)'
  jobs:
  - job: TerraformValidate
    displayName: 'Terraform Init / Validate / Plan (matrix per infra env)'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      matrix:
        dev:
          envName: 'dev'
          tfvarsFile: 'dev/dev.tfvars'
          backendConfig: 'dev/backend.conf'
        stage:
          envName: 'stage'
          tfvarsFile: 'stage/stage.tfvars'
          backendConfig: 'stage/backend.conf'
        prod:
          envName: 'prod'
          tfvarsFile: 'prod/prod.tfvars'
          backendConfig: 'prod/backend.conf'

    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'

    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az account show
      displayName: 'Azure Login'

    - task: AzureCLI@2
      name: tfInit
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(workingDirectory)'
        inlineScript: |
          set -e
          echo "Initializing Terraform with backend config: $(backendConfig)"
          terraform init -input=false -backend-config="$(backendConfig)"
      displayName: 'Terraform Init (env: $(envName))'

    - task: AzureCLI@2
      name: tfValidate
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(workingDirectory)'
        inlineScript: |
          set -e
          terraform validate
      displayName: 'Terraform Validate (env: $(envName))'

    - task: TerraformTaskV4@4
      name: tfPlan
      inputs:
        provider: 'azurerm'
        command: 'plan'
        environmentServiceNameAzureRM: '$(serviceConnection)'
        commandOptions: '-var-file="$(tfvarsFile)" -out="$(workingDirectory)/$(envName)/tfplan-$(envName)"'
        workingDirectory: '$(workingDirectory)'
      displayName: 'Terraform Plan (env: $(envName))'

    # - task: AzureCLI@2
    #   name: tfPlan
    #   inputs:
    #     azureSubscription: '$(serviceConnection)'
    #     scriptType: 'bash'
    #     scriptLocation: 'inlineScript'
    #     workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
    #     inlineScript: |
    #       set -e
    #       # Create plan directory if it doesn't exist
    #       mkdir -p $(Build.ArtifactStagingDirectory)/$(envName)
          
    #       echo "Planning Terraform with vars file: $(tfvarsFile)"
    #       terraform plan -input=false \
    #         -var-file="$(tfvarsFile)" \
    #         -out="$(Build.ArtifactStagingDirectory)/$(envName)/tfplan"
    #   displayName: 'Terraform Plan (env: $(envName))'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(workingDirectory)/$(envName)'
        artifactName: 'tfplan-$(envName)'
        publishLocation: 'pipeline'
      displayName: 'Publish Terraform Plan (env: $(envName))'

- stage: ValidateHelmCharts
  displayName: 'Validate Helm Charts (lint + render templates per env)'
  dependsOn: ValidateTerraform
  condition: succeeded()
  jobs:
  - job: HelmValidate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    # Cache Helm chart repository/cache to speed repeated operations (optional)
    - task: Cache@2
      displayName: 'Cache Helm home/cache'
      inputs:
        key: 'helm | $(Agent.OS) | charts | $(Build.SourceVersion)'
        path: '$(HOME)/.cache/helm'
        restoreKeys: |
          helm | $(Agent.OS) | charts
      condition: succeededOrFailed()

    - script: |
        set -e
        cd charts
        
        # Update umbrella chart dependencies
        echo "Updating Helm dependencies..."
        helm dependency update
        
        # Lint sub-charts individually
        echo "Linting sub-charts..."
        for subchart in backend frontend ingress; do
          if [ -d "$subchart" ]; then
            echo "Linting $subchart..."
            helm lint "$subchart" || true
          fi
        done
        
        # Lint umbrella chart
        echo "Linting umbrella chart..."
        helm lint . || true
        
        # Render templates for each environment to validate
        envs=("dev" "stage" "prod")
        for env in "${envs[@]}"; do
          echo "==========================================="
          echo "Rendering templates for environment: $env"
          echo "==========================================="
          
          if [ -f "values.$env.yaml" ]; then
            helm template aks-app . \
              --values "values.$env.yaml" \
              --set global.image.repository="dummy.azurecr.io" \
              --set global.image.tag="$(imageTag)" \
              --set global.keyVault.name="dummy-kv" \
              --set global.keyVault.tenantId="00000000-0000-0000-0000-000000000000" \
              --debug \
              > "/tmp/rendered-$env.yaml"
            
            echo "✓ Successfully rendered for $env environment"
          else
            echo "⚠ Warning: values.$env.yaml not found, skipping"
          fi
        done
        
        echo "==========================================="
        echo "✓ All Helm chart validations completed"
        echo "==========================================="
      displayName: 'Helm lint & template validation (per environment)'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: PackageCharts
  displayName: 'Package Helm Charts (artifact)'
  dependsOn: ValidateHelmCharts
  condition: succeeded()
  jobs:
  - job: PackageCharts
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    - script: |
        set -e
        cd charts
        
        # Update dependencies before packaging
        echo "Updating Helm dependencies..."
        helm dependency update
        
        # Create artifact directory
        mkdir -p "$(Build.ArtifactStagingDirectory)/charts"
        
        # Package the umbrella chart (this will include all sub-charts)
        echo "Packaging umbrella chart..."
        helm package . \
          -d "$(Build.ArtifactStagingDirectory)/charts" \
          --version "$(imageTag)" \
          --app-version "$(imageTag)"
        
        # Optionally package sub-charts individually if needed for separate deployments
        echo "Packaging individual sub-charts..."
        for subchart in backend frontend ingress; do
          if [ -d "$subchart" ]; then
            echo "Packaging $subchart..."
            helm package "$subchart" \
              -d "$(Build.ArtifactStagingDirectory)/charts" \
              --version "$(imageTag)" \
              --app-version "$(imageTag)"
          fi
        done
        
        echo "==========================================="
        echo "Packaged charts:"
        ls -lh "$(Build.ArtifactStagingDirectory)/charts"
        echo "==========================================="
      displayName: 'Package Helm Charts (version=$(imageTag))'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/charts'
        artifactName: 'helm-charts'
        publishLocation: 'pipeline'
      displayName: 'Publish Helm Packages as Artifact'
