# ============================================================================
# Infrastructure CI Pipeline
# 
# This pipeline validates, plans, and packages infrastructure and applications:
# 
# Stage 1: ValidateTerraform
#   - Validates Terraform configurations for dev, stage, prod
#   - Creates Terraform plans (infrastructure + cluster tools)
#   - Includes: AKS, ACR, KeyVault, CosmosDB, Prometheus, Grafana, Nginx
#
# Stage 2: ValidateHelmCharts
#   - Lints Helm charts
#   - Validates templates with environment-specific values
#   - Tests rendering for all environments
#
# Stage 3: PackageCharts
#   - Packages Helm charts as artifacts
#   - Includes deploy.sh script for easy deployment
#
# Deployment:
#   - Infrastructure: Apply Terraform manually or via release pipeline
#   - Applications: Use deploy.sh script from artifacts
#   - Monitoring: Prometheus + Grafana (with optional Azure AD auth)
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - infra/*
      - charts/*
      - azure-pipelines/azure-pipelines-infra.yml

variables:
  # Use a specific version (recommended) or 'latest' to pick newest available in installer task.
  terraformVersion: 'latest' 
  workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
  serviceConnection: 'Azure ARM' # Replace with your Azure service connection name
  imageTag: '$(Build.BuildId)'   # CI build artifact tag - avoid "latest"
  acrName: ''                    # Set to your ACR name to push packaged charts (optional)
  terraformStateRG: 'terraform-state-rg'        # adjust if different
  terraformStateStorageAccount: 'tfstatemcda2025' # adjust if different
  terraformStateContainer: 'tfstate'            # adjust if different
  
  # Grafana Azure AD Authentication (Optional)
  # To enable Microsoft Entra ID auth for Grafana, set these as pipeline variables:
  #   1. Go to Pipeline â†’ Edit â†’ Variables
  #   2. Add variable: TF_VAR_grafana_azure_ad_client_id (mark as secret)
  #   3. Add variable: TF_VAR_grafana_azure_ad_client_secret (mark as secret)
  # See infra/GRAFANA_AZURE_AD_SETUP.md for Azure AD app registration setup
  # If not set, Grafana will use default admin/admin authentication

stages:
- stage: ValidateTerraform
  displayName: 'Validate Terraform Configuration (per environment)'
  jobs:
  - job: TerraformValidate
    displayName: 'Terraform Init / Validate / Plan (matrix per infra env)'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      matrix:
        dev:
          envName: 'dev'
          tfvarsFile: 'dev/dev.tfvars'
          backendConfig: 'dev/backend.conf'
        stage:
          envName: 'stage'
          tfvarsFile: 'stage/stage.tfvars'
          backendConfig: 'stage/backend.conf'
        prod:
          envName: 'prod'
          tfvarsFile: 'prod/prod.tfvars'
          backendConfig: 'prod/backend.conf'

    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'

    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az account show
      displayName: 'Azure Login'

    - task: AzureCLI@2
      name: tfInit
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(workingDirectory)'
        inlineScript: |
          set -e
          echo "Initializing Terraform with backend config: $(backendConfig)"
          terraform init -input=false -backend-config="$(backendConfig)"

          # Ensure lock file is included in artifact
          echo "Copying lock file to environment directory..."
          mkdir -p $(envName)
          cp .terraform.lock.hcl $(envName)/.terraform.lock.hcl || echo "Warning: Lock file not found"
          echo "âœ“ Lock file copied successfully"
      displayName: 'Terraform Init (env: $(envName))'

    - task: AzureCLI@2
      name: tfValidate
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '$(workingDirectory)'
        inlineScript: |
          set -e
          terraform validate
      displayName: 'Terraform Validate (env: $(envName))'

    # - task: TerraformTaskV4@4
    #   name: tfPlan
    #   inputs:
    #     provider: 'azurerm'
    #     command: 'plan'
    #     environmentServiceNameAzureRM: '$(serviceConnection)'
    #     commandOptions: '-var-file="$(tfvarsFile)" -out="$(workingDirectory)/$(envName)/tfplan-$(envName)"'
    #     workingDirectory: '$(workingDirectory)'
    #   displayName: 'Terraform Plan (env: $(envName))'
    #   env:
    #     # Pass Azure AD credentials if set as pipeline variables (optional)
    #     TF_VAR_grafana_azure_ad_client_id: $(TF_VAR_grafana_azure_ad_client_id)
    #     TF_VAR_grafana_azure_ad_client_secret: $(TF_VAR_grafana_azure_ad_client_secret)

  - job: TerraformConfigPublish
    displayName: 'Publish Terraform Configuration'
    dependsOn: TerraformValidate
    condition: succeeded()
    steps:
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(workingDirectory)'
        artifactName: 'terraform-config'
        publishLocation: 'pipeline'
      displayName: 'Publish Terraform Configuration'

- stage: ValidateHelmCharts
  displayName: 'Validate Helm Charts (application manifests)'
  dependsOn: ValidateTerraform
  condition: succeeded()
  jobs:
  - job: HelmValidate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    - script: |
        set -e
        cd charts
        
        # Update umbrella chart dependencies
        echo "Updating Helm dependencies..."
        helm dependency update
        
        # Lint sub-charts individually
        echo "Linting sub-charts..."
        for subchart in backend frontend ingress; do
          if [ -d "$subchart" ]; then
            echo "Linting $subchart..."
            helm lint "$subchart" || true
          fi
        done
        
        # Lint umbrella chart (warning about missing templates/ dir is expected for umbrella charts)
        echo "Linting umbrella chart..."
        helm lint . || echo "âš  Umbrella chart lint warnings are expected (no templates directory)"
        
        # Render templates for each environment to validate
        envs=("dev" "stage" "prod")
        for env in "${envs[@]}"; do
          echo "==========================================="
          echo "Rendering templates for environment: $env"
          echo "==========================================="
          
          if [ -f "values.$env.yaml" ]; then
            helm template aks-app . \
              --values "values.$env.yaml" \
              --set global.image.repository="dummy.azurecr.io" \
              --set global.image.tag="$(imageTag)" \
              --set global.keyVault.name="dummy-kv" \
              --set global.keyVault.tenantId="00000000-0000-0000-0000-000000000000" \
              --debug \
              > "/tmp/rendered-$env.yaml"
            
            echo "âœ“ Successfully rendered for $env environment"
          else
            echo "âš  Warning: values.$env.yaml not found, skipping"
          fi
        done
        
        echo "==========================================="
        echo "âœ“ All Helm chart validations completed"
        echo "==========================================="
      displayName: 'Helm lint & template validation (per environment)'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: PackageCharts
  displayName: 'Package Helm Charts (artifact)'
  dependsOn: ValidateHelmCharts
  condition: succeeded()
  jobs:
  - job: PackageCharts
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: 'latest'
      displayName: 'Install Helm'

    - script: |
        set -e
        cd charts
        
        # Update dependencies before packaging
        echo "Updating Helm dependencies..."
        helm dependency update
        
        # Create artifact directory
        mkdir -p "$(Build.ArtifactStagingDirectory)/charts"
        
        # Package the umbrella chart (this will include all sub-charts)
        echo "Packaging umbrella chart..."
        helm package . \
          -d "$(Build.ArtifactStagingDirectory)/charts" \
          --version "$(imageTag)" \
          --app-version "$(imageTag)"
        
        # Optionally package sub-charts individually if needed for separate deployments
        echo "Packaging individual sub-charts..."
        for subchart in backend frontend ingress; do
          if [ -d "$subchart" ]; then
            echo "Packaging $subchart..."
            helm package "$subchart" \
              -d "$(Build.ArtifactStagingDirectory)/charts" \
              --version "$(imageTag)" \
              --app-version "$(imageTag)"
          fi
        done
        
        echo "==========================================="
        echo "Packaged charts:"
        ls -lh "$(Build.ArtifactStagingDirectory)/charts"
        echo "==========================================="
        
        echo ""
        echo "==========================================="
        echo "ðŸ“¦ Adding deployment script to artifacts"
        echo "==========================================="
        cp deploy.sh "$(Build.ArtifactStagingDirectory)/charts/deploy.sh"
        chmod +x "$(Build.ArtifactStagingDirectory)/charts/deploy.sh"
        echo "âœ“ Deploy script included"
        echo ""
        echo "To deploy after downloading artifacts:"
        echo "  cd helm-charts"
        echo "  ./deploy.sh <environment> <image-tag>"
        echo ""
        echo "Example:"
        echo "  ./deploy.sh dev $(imageTag)"
        echo "==========================================="
      displayName: 'Package Helm Charts (version=$(imageTag))'
      workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/charts'
        artifactName: 'helm-charts'
        publishLocation: 'pipeline'
      displayName: 'Publish Helm Packages as Artifact'
